<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="..\..\styles\styles.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 7</title>
</head>
<body>
<div class="container">

    
    <div class="menu-links">
        <ul>
            <li><a href="../../index.html">Home</a></li>
            <li class="present-page"><a href="#">Lectures</a></li>
            <li><a href="https://youtube.com/channel/UCJAgw1niUkaShdmA5aAZdQw">Video Lectures</a></li>
            <li><a href="../../about.html">About</a></li>
        </ul>
    </div>



    <nav class="contents">
        <h1 id="contentsheading">CONTENTS</h1>
        <ul>
            <li><a href="../week1/week1.html#week1">1 &nbsp; Week 1</a></li>
            <li><a href="../week1/week1.html#simplegcd">1.1 &nbsp; Algorithms and programming: simple gcd</a></li>
            <li><a href="../week1/week1.html#improvegcd">1.2 &nbsp; Improving naive gcd</a></li>
            <li><a href="../week1/week1.html#euclidgcd">1.3 &nbsp; Euclid's algorithm for gcd </a></li>
            <li><a href="../week1/week1.html#downloadpython">1.4 &nbsp; Downloading and installing Python </a></li>
            <br>
            <li><a href="../week2/week2.html#week2">2 &nbsp; Week 2</a></li>
            <li><a href="../week2/week2.html#Assignmentstatement">2.1 &nbsp; Assignment statement, basic types - int, float, bool </a></li>
            <li><a href="../week2/week2.html#strings">2.2 &nbsp; Strings</a></li>
            <li><a href="../week2/week2.html#lists">2.3 &nbsp; Lists </a></li>
            <li><a href="../week2/week2.html#controlflow">2.4 &nbsp; Control Flow </a></li>
            <li><a href="../week2/week2.html#functions">2.5 &nbsp; Functions </a></li>
            <li><a href="../week2/week2.html#example1">2.6 &nbsp; Examples </a></li>
            <br>
            <li><a href="../week3/week3.html#week3">3 &nbsp; Week 3</a></li>
            <li><a href="../week3/week3.html#range">3.1 &nbsp; More about range()</a></li>
            <li><a href="../week3/week3.html#manupulatinglists">3.2 &nbsp; Manipulating lists</a></li>
            <li><a href="../week3/week3.html#breakoutofloop">3.3 &nbsp; Breaking out of a loop </a></li>
            <li><a href="../week3/week3.html#Arrayvslist">3.4 &nbsp; Arrays vs lists, binary search </a></li>
            <li><a href="../week3/week3.html#Efficiency">3.5 &nbsp; Efficiency</a></li>
            <li><a href="../week3/week3.html#SelectionSort">3.6 &nbsp; Selection Sort </a></li>
            <li><a href="../week3/week3.html#InsertionSort">3.7 &nbsp; Insertion Sort </a></li>
            <li><a href="../week3/week3.html#Recursion">3.8 &nbsp; Recursion </a></li>
            <br>
            <li><a href="../week4/week4.html#week4">4 &nbsp; Week 4</a></li>
            <li><a href="../week4/week4.html#Mergesort">4.1 &nbsp; Mergesort </a></li>
            <li><a href="../week4/week4.html#Mergesortanalysis">4.2 &nbsp; Mergesort analysis</a></li>
            <li><a href="../week4/week4.html#Quicksort">4.3 &nbsp; Quicksort </a></li>
            <li><a href="../week4/week4.html#Quicksortanalysis">4.4 &nbsp; Quicksort analysis </a></li>
            <li><a href="../week4/week4.html#TuplesandDictionary">4.5 &nbsp; Tuples and Dictionaries </a></li>
            <li><a href="../week4/week4.html#Functiondefinitions">4.6 &nbsp; Function Definitions </a></li>
            <li><a href="../week4/week4.html#listcomprehensions">4.7 &nbsp; List Comprehensions </a></li>
            <br>
            <li><a href="../week5/week5.html#week5">5 &nbsp; Week 5</a></li>
            <li><a href="../week5/week5.html#ExceptionHandling">5.1 &nbsp; Exception Handling</a></li>
            <li><a href="../week5/week5.html#stdio">5.2 &nbsp; Standard input and output</a></li>
            <li><a href="../week5/week5.html#Handlingfiles">5.3 &nbsp; Handling Files </a></li>
            <li><a href="../week5/week5.html#StringFunctions">5.4 &nbsp; String Functions </a></li>
            <li><a href="../week5/week5.html#formatprintedoutput">5.5 &nbsp; Formatting Printed Output </a></li>
            <li><a href="../week5/week5.html#PassdelandNone">5.6 &nbsp; Pass, del() and None </a></li>
            <br>
            <li><a href="../week6/week6.html#week6">6 &nbsp; Week 6</a></li>
            <li><a href="../week6/week6.html#Nqueens">6.1 &nbsp; Backtracking, N queens </a></li>
            <li><a href="../week6/week6.html#GlobalscopeNestedfunctions">6.2 &nbsp; Global scope, nested functions</a></li>
            <li><a href="../week6/week6.html#GeneratingPermutations">6.3 &nbsp; Generating permutations </a></li>
            <li><a href="../week6/week6.html#SetsStacksQueues">6.4 &nbsp; Sets, stacks, queues </a></li>
            <li><a href="../week6/week6.html#Priorityqueuesandheaps">6.5 &nbsp; Priority queues and heaps </a></li>
            <br>
            <li><a href="#week7">7 &nbsp; Week 7</a></li>
            <li><a href="#AbstractClassesObjects">7.1 &nbsp; Abstract datatypes, classes and objects</a></li>
            <li><a href="#ClassesandObjectspython">7.2 &nbsp; Classes and objects in Python</a></li>
            <li><a href="#userdefinedlists">7.3 &nbsp; User defined lists </a></li>
            <li><a href="#Searchtrees">7.4 &nbsp; Search trees </a></li>
            <br>
            <li><a href="../week8/week8.html#week8">8 &nbsp; Week 8</a></li>
            <li><a href="../week8/week8.html#MemoizationandDP">8.1 &nbsp; Memoization and dynamic programming </a></li>
            <li><a href="../week8/week8.html#Gridpaths">8.2 &nbsp; Grid paths</a></li>
            <li><a href="../week8/week8.html#LCSubsequence">8.3 &nbsp; Longest common subsequence </a></li>
            <li><a href="../week8/week8.html#Matrixmultiply">8.4 &nbsp;  Matrix multiplication </a></li>
            <li><a href="../week8/week8.html#Wrapup">8.5 &nbsp; Wrap-up, Python vs other languages </a></li>
        </ul>
    </nav>



    <div id="W7" class="material">
        <h1 id="week7">Week 7</h1>
        <div id="lectrue37">
            <h2 id="AbstractClassesObjects">7.1 &nbsp;  Abstract datatypes, classes and objects </h2>
            <p>
                We have seen how to implement data structures such as, stacks, queues and heaps using
                the built in list type of Python. It turns out that one can go beyond the built in types in
                python and create our own data types. So, we will look at this in more detail in this
                weeks' lectures. 
                Let us revisit what we lean by a data structure. A data structure is basically an
                organization of information whose behavior is defined through an interface. So an
                interface is nothing but the allowed set of operations, for instances for a stack the
                allowed set of operations are push and pop. And of course, we can also query whether a
                stack is empty or not.
                Likewise, for a queue the only way we can modify a queue is to add something to the tail
                of the queue using the function add q and remove the element at the head of the queue
                using the function remove q. And for a max heap for instance, we have the functions
                insert to add an element and delete max which removes the largest element from the
                heap.
                Now, just because we implement a heap as a list it does not mean that the functions that
                are defined for lists are actually legal for the heap. So if we have a heap h, which is
                implemented as a python list though the list will allow an append function. The append
                function on it is own does not insert a value and maintain the heap property. So, in
                general the call such as h dot append 7 would not be legal.
                <br><br>
                So, we want to define new abstract data types in terms of the operations allowed. We do
                not want to look at the implementation and ask whether it is a list or not, because we do
                not want the implementation to determine what is allowed, we only want the actual
                operations that we define as the abstract interface to be permitted. 
                For instance if we have a stack s and we push value v then the property of a stack
                guarantees that if we immediately apply pop the value we get back is our last value push
                and therefore we should get back v. In other words, if we execute this sequence we first
                to s dot push and then we do a pop then the value that we pushed must be the value that
                we get back.
                This is a way of abstractly defining the property of a stack and how push and pop interact
                without actually telling us anything about how the internal values are represented. In the
                same way if we have an empty queue and we add to it two elements u and v and then we
                remove the head of the queue, then we expect that we started with an empty queue and
                then we put in from this end u and then we put in a v, then the element that comes out
                should be the first element namely u. In other words assuming that this is empty then if
                we add u and add v and then remove the head we should get back first element that we
                put in namely u.
                The important thing is that we would like to define the behavior of a data type without
                reference to the implementation. Now this can be very tedious because you have to make
                sure that it capture all the properties between functions, but this can be done and this is
                technically how an abstract data type is defined. Now large purposes we will normally
                define it more informally and we will make reference to the implementation, but we
                definitely do not want the implementation to determine how these functions work.
                <br><br>
                In other words, we should be able to change one implementation to another one such that
                the functions behave the same way and the outside user has no idea which
                implementation is used. Now this is often the case when we need to optimize
                implementation, we might come up with an inefficient implementation and then optimize
                it. For instance we saw that for a priority queue we could actually implement it as a
                sorted list and then we could implement insert as an insert operation in a sorted list
                which you take order n time, but delete max would just remove the head of the list.
                This is not optimal because over a sequence of n inserts and deletes this takes time order
                n square. So if we replace the internal implementation from a sorted list to a heap we get
                better behavior, but in terms of the actual values that the user sees as a sequence of
                inserts and delete max the user does not see any difference between the sorted list
                implementation and the heap implementation. Perhaps, there is a perception that the one
                is faster than the other, but the actual correctness of the implementation should not be
                affected by how you choose to represent the data. So, this is the essence of defining an
                Abstract datatype.
                <br><br>
                So, good way to think of an abstract datatype is as a black box which allows limited
                interaction. Imagine something like an ATM machine. So, we have the data structure as a
                black box and we have certain buttons which are the public interface, these are the
                functions that we are allowed to use. In this picture imagine this is a stack and the
                buttons were allowed to push are pop and push let they are allowed to remove the top
                elements from the stack; they are allowed to put an element into the stack. 
                Now this requires us to also add and view things from the stack, so we also have a slot
                for input which is shown as a kind of a thing at the bottom here we have the slot for
                input. And we have the way to receive information about the state of the stack. So we can
                imagine that we have some kind of a display.
                This is typically how we would like to think of a data structure, we do not want to know
                what is inside the black box we just want to specify that if we do a sequence of button
                pushes and we start supplying input through the input box what do we expect to see if the
                display. Other than this, no other manipulation should be allowed. We are not allowed to
                exploit what is inside the box in order to quickly get access say to the middle of a stack
                or the middle of a queue. So we do not want such operations, we only want those
                operations which the externally visible interface or the buttons in this case of the black
                box picture allow us to use.
                <br><br>
                In a sense this is already implemented when we use the built in data types of python, if
                we announce that the name l is of type list by setting l to the empty list then immediately
                python will allow us to use operations like append and extend on this list, but because it
                is of list type and not dictionary type we would not be able to execute an operations such
                as keys which is defined for dictionaries are not list. 
                Likewise if we define d to be an empty dictionary then we can use a function such as d
                dot values to get the list of values currently stored, but we cannot manipulate d as a list.
                So, we cannot say d dot append it will give us an error. Python uses the type information
                that it has about the value give assign to a name to determine what functions are legal
                which is exactly what we are trying to do with these abstract data types. We are trying to
                say that the data type on it is own should allow only certain limited types of access
                whose behavior is specified without telling us anything about the internal
                implementation.
                <br><br>
                Remember for instance we saw that in a dictionary even if we add a sequence or values
                in the particular order we ask for the values after sometime they may not written in the
                same order, because internally there is some optimization in order to make it fast to look
                up a value for it. We have no idea actually how dictionaries implemented inside, but what
                we do know is that if we provide a key and that key is a valid key we will get the
                associated with that key, we do not ask how this is done and we do not know whether
                from one version of python to the next the way in which this is implemented changes.
                Our question is, that instead of using the built in list for stacks, queues and heaps and
                other data structures can we also defined a data type in which certain operations are
                permitted according to the type that we start with.
                <br><br>
                This is one of the main things which are associated with a style of programming called
                Object Oriented program. In object oriented program, we can provide data type
                definitions for new data types in which we do precisely what we have been talking about
                we describe the public interface, that is the operations that are allowed on the data and
                separately we provide an implementation which should be private, we will discuss later
                that in python we do not actually have a full notion of privacy because of the nature of
                the language. 
                <br><br>
                But ideally the implementation should not be visible outside only the interface should
                allow the user to interact with the implemented data. Of course, the implementation must
                be such that the functions that are visible to the user behave correctly.
                So here for instance if we had a heap the public interface would say insert and delete
                max, the private implementation may be a sorted list or it may be a heap and then we
                would then have to ensure that if we are using a sorted list we implement delete max and
                insert in the correct way and if we switch from that to a heap the priority queue
                operations remain the same.
                <br><br>
                In the terminology of object oriented programming there are two important concepts;
                Classes and Objects. A class is a template very much like a function definition is a
                template, when we say def and define a function the function does not execute it just
                gives us a blue print saying that this is what would happen if this function were called
                with a particular argument and that argument to be substituted for the formal parameter
                in the function and the code in the function will be execute to the corresponding value.
                In the same way a class sets up a blue print or a template for a data type. It tells us two
                things it tells us; what is the internal implementation? How is data stored? And it gives
                us the functions that are used to implement the actual public interface. So, how you
                manipulate the internal data in order to effect the operations that the public interface
                allows. Now once we have this template we can construct many instances of it. So, you
                have the blue print for a stack you can construct many independent stacks, each
                independent stack has it is own data that stacks do not interfere with each other. 
                Each of them has a copy of the function that we have defined associated with it. Rather
                than the kind of the main difference from classical programming is, in classical
                programming you would have for instance a function like say push define and it will
                have two parameters typically a stack and a value. So, you have one function and then
                you provide it the stack that you want to manipulate.
                On the other hand, now we have several stacks s1, s2, s3, etcetera which are created as
                instance as class, and logically each of them has it is own push function. So there is a
                push associated with s1, that the push associated is s2, the push associated with s3 and so
                on. Each of them is a copy of the same function derived from this template, but this
                implicitly attach to the single object. So, this is just a slight difference in perspective
                instead of having a function to which you pass the object that you want to manipulate
                you have the object and you tell it what function to apply to itself.
                So, let us look at a kind of example this would not be a detailed example it will just give
                you a flavor of what we are talking about. Here is a skeleton of a definition of a class
                heap. So now, we instead of using the built in list we want to define our own data type
                heap. So there are some function definitions. These def statements and these correspond
                to definition in the functions and what we will see is that inside these definitions we will
                have values which are stored in each copy of the heap. So, just to get a little bit of an
                idea about how this is would work.
                <br><br>
                When we create on object of type heap we call it like a function. So, we say h is equal to
                heap l, so this implicitly says give me an instance of the class heap with the initially
                value l passed to it now this calls this function init which is why it is called init. So, init
                is what is called a constructor. A constructor is a function that is called when the object is
                created and sets it up initially in this particular case our constructor is presumed to take
                an arbitrary list of values say 14, 32, 15 and heapify it. So, somewhere inside the code of
                init there will be a heapification operation which we are not actually shown in this slide.
                This is how you create objects. You first define a class we will look at a complete
                example soon, we define a class and then you call the class sort of like a function and the
                name that is attach to this function call or this class were becomes a new object, As we
                said we have functions like insert and delete max define for heaps, but it is like we have
                the separate copy of this function for each individual heaps. 
                In this case we are created a heap h, so we want to tell h insert in yourself the value 70.
                So, we write that as insert with respect to h. So, h dot insert 17, as suppose to insert h 17
                which would be the normal functional style of writings. We would normally pass it the
                heap and the value, here instead we say given the heap h apply to the heap h the function
                insert with the argument 70.
                The next line says apply to the heap h in function insert to the value 28 and then for
                instance we can now ask h to return the maximum value by it is an h dot delete max and
                store the return value in the main v.
                <br><br>
                So, what we would like to emphasize is that an abstract data type should be seen as a
                black box. Like a black box has a public interface the buttons that you can push to update
                and query the data type to add things, delete things, and find out what whether the data
                type is empty and so on. Inside we have a private implementation. This actually stores
                data in some particular way to make the public functions work correctly. But the
                important thing is, changing the private implementation should not affect how the
                functions behave in terms of input and output. 
                They may behave differently in terms of efficiency, you might see that one version is
                faster than another or one version slower than another, but this is not the same as saying
                that the functions change. So, we do not want the values to change, if we have a priority
                queue and we insert a set of values and then delete max no matter how the priority queue
                is actually implemented internally the delete max should give us the same value at the
                end.
                So, we saw that python supports object oriented programming, we shall look at it in more
                detail in the next couple of lectures in these weeks course, but the main concept
                associated with this objected oriented programming are classes and objects. Classes are
                templates for data types and objects are instances of these classes they have a concrete
                data types which we use in our program.
                <br><br>
                
            </p>
        </div>
        <!--End of lecture 37-->

        <div id="lectrue38">
            <h2 id="ClassesandObjectspython">7.2 &nbsp; Classes and objects in Python </h2>
            <p>
                In the lecture, we saw that in object oriented programming we define a data type through
                a template called a class, which defines the internal data implementation, and the
                functions that we use to manipulate the data type. And then we create instances of this
                data type as objects.
                <br><br>
                We saw a skeleton implementation of a heap. This had a special function called init,
                which was used to create the heap, and then we had functions insert and delete. Now one
                thing which we did not explain is this argument self that run through this. This is a
                convention which we have in python that every function defined inside a class should
                have as its first parameter the name self, now it need not be called self, but it is less
                confusing to always call it, self. 
                Let us just assume that this parameter is always there and it is called self. Now, what is
                self, self is a name that is used inside the class to refer to the object that we are currently
                looking at. For instance, if we are dealing with this heap h, when we say h dot insert then
                this insert is using the value 17. So, 17 is the value x which is being passed to insert, and
                h is the value on which the 17 should be added and that is a name for self. So, self in
                other words, tells the function which object it is operating on itself. It is a name to itself
                because you are telling a function an object heap h insert 17 into your ‘self’.
                In that sense, my values are denoted by self and inside a heap, it can may be refer to
                other heaps. We will see a little later that we can take one value and refer to another
                value. There will be my values and there will be other values. So, my values are always
                implicitly called self, because that is the one that is typically manipulated by a function.
                <br><br>
                To make this a little clearer, let us look at a slightly simpler example than heaps to get all
                the notations and the terminology correct for us.
                Our first example is just a representation of a point x y. So, we are just thinking about a
                normal coordinate system, where we have the x-axis, the y-axis. Therefore, a given point
                is given some coordinate like a comma b. This is a point with x-coordinate a and ycoordinate b, this is a familiar concept that all of you must have seen in mathematics
                somehow. So, we want to associate with such an object two quantities - the x-coordinate
                and the y-coordinate and this is set up by the init function by passing the values a and b
                that you want point to have. 
                And now we have within the point, we have these two attributes x and y, means every
                point looks like this. It has an x value and a y value, and this x value is something and
                the y value is something. And if we change this x and y value, then the point shifts
                around from one place to another.
                Now, in order to designate that the x and y belong to this point and no other, we prefix it
                by self. So, self dot x refers to the x value within this point myself, self dot y is y value
                within myself. If you have a generic point p then we have p dot x, p dot y these will refer
                to the values x and y the names x and y associated with the point p. 
                Inside the class definition, self refers to the value of the attribute or the name within this
                particular object. Now this particular object changes as we move from one object to
                another, but for every object self is itself. So, for p 1 if I tell something about p 1 well in
                the context of p 1 self is p 1. If I have different point p 2 in the context of p 2, self is p 2.
                This is an important thing. Just remember that every function inside a class definition
                should always have the first argument as self and then the actual argument. So, init in
                this case takes two arguments, but we always insert a third argument.
                <br><br>
                Let us look at how this works. For instance, if we say p is equal to point 3, 2; then 3 will
                be passed as a, and 2 will be passed as b. And this will set up a point that we have drawn
                here, which internally is represented as self dot x is 3 and self dot y is 2. Now here is a
                slightly different function, it takes a point and shifts it. So, you want to say shift this to 3
                plus delta x and 4 plus delta y. This function we called translate. So, it takes the amount
                of shift as the argument, delta x and delta y. And as usual we are always providing self as
                the default first argument. 
                It just keep this in mind every python function, every python class, if you want to use a
                function in the object oriented style, the first argument must necessarily be self and then
                the real arguments. So, what do we want to do when we want to translate a point, we
                want to take self dot x and move it to self dot x plus the value delta x. So, you want self
                dot x plus delta x. Now, this is a very common paradigm in python and other
                programming languages where you want to take a name say z, and then you want to shift
                it by some amount, say z plus 6 or z is equal to z minus 6. 
                Whenever we have this kind of a thing where the same name is being updated, there is a
                short form where we can combine the operation with the assignment. So, self dot x plus
                equal to delta x is just a short cut in python for self dot x equal to self dot x plus delta x;
                it means that implicitly the name on the left is the first argument to the operation
                mentioned along with the assignment operation. This is a very convenient shortcut which
                allows us to save some typing. Instead of writing self dot x equal to self dot x plus delta
                x we just say self dot x plus equal to delta x. This shifts the x coordinate of the current
                point by the argument provided to translate. Similarly, self dot y plus equal to delta y will
                shift the argument by the amount provided by delta y. 
                <br><br>
                For instance, now if we say p dot translate 2 1 then we get a new point which 3 plus 2 5
                for the x coordinate and 2 plus 1 3, so this 3 plus 2 gives us 5, and 2 plus 1 gives us 3.
                This shifts the point from 3, 2 to 5, 3. This is how we define these internal. The internal
                implementation is defined inside the init function; this is the function that is called when
                the point is set up and this associates these internal names x and y with the objects. This
                is where the implementation really gets set up, and then the functions that we define
                externally like translate manipulate this internal representation in an appropriate way, so
                that it changes consistently with what you expect the functions to be.
                Let us look at different functions. So supposing we want to compute the distance of a
                point from the origin. So, we want to know what is this distance. This distance by
                Pythagoras' theorem is nothing but the square root of x square plus y square. So,
                remember this is like a hypotenuse of a right angled triangle. So, you take a x square plus
                y square root and you get d. 
                If you want the distance of a point, we do not give it any arguments, but we always have
                this default argument self. So, we want to know what is the distance from 0, 0 to the
                current point. So, we would say something like in our earlier case p is equal to point say
                3 comma 4 and then we will say p dot o distance to get its distance. Maybe we would
                assign this to a name, let us not call it. So, we have might assign this to a name like n
                right.
                <br><br>
                So, when we do this, it will look at the current value of self dot x, the current value of
                self dot y, square them, add them and take the square root. Now one thing to remember is
                that actually square root is not a function available by default in python. So, you actually
                have to import the math library. At the top of your class definition, you should have
                remembered to write from math import star. Assuming that we are done that then square
                root is defined. This is a typical function which returns some information about the point;
                the earlier function just translated the point, did not tell us anything; this is the function
                that returns information about the point.
                Now if o distance is something that we need to do often, then may be it's useful to just
                keep the point in a different representation. So, you may remember or you may have seen
                somewhere in high school mathematics that if you take the point x, y then an alternative
                way of representing where this point is to actually use polar coordinates. So, you can
                keep this distance and you can keep this angle. So, if I have r and theta it's the same
                information as keeping x and y. 
                The connection between the two is that x is r cos theta where cos is the trigonometric
                cosine function; y is equal to r sin theta. And on the other hand, if I have x and y then I
                can recover r as we just did for o distance it's the square root of x square plus y square,
                and theta so y by x is actually if you if you divided y by x you get tan of theta that is
                because it's sin divided by cos and the r cancels. So, y by x is tan theta, so theta is the tan
                inverse of y by x. Now speaking of changing implementation, we could change our
                implementation, so that we do not keep the internal representation in terms of x and y,
                we actually keep it in terms of r and theta, but the functions remain the same. 
                <br><br>
                For instance, we could take the earlier definition and change it. So, we again pass it x
                and y. So, from the user's prospective, the user believes that the point is defined in terms
                of the x and y coordinate, but instead of using a and b as the argument directly to set up
                the point, we first set up the r - the radius by taking square root of a square plus b square.
                And then depending, so we want to divide b by a, but if a is 0, then we have a special
                case b by a will give us an error. So, if a is 0, we set the angle to be 0; otherwise, this is
                the python function in the math library for tan inverse, arc tan, we set theta to be the arc
                tan b minus a b divided a. So, we internally manipulate the x y version to r theta using
                the same formula that we had shown before which is that r is square root of x square plus
                y square and theta is tan inverse of y by x. Only thing we have to take care is when x is
                equal to 0, we have to manually set theta to 0.
                <br><br>
                Now internally we are now keeping self dot r and self dot theta. We are not keeping self
                dot x and self dot y. This is useful because if you want the o distance - the origin distance
                we just have to return the r value we do not do any computation. So, in other words if we
                are going to use o distance very often then it is better to use the calculation square root a
                square plus b square once at the beginning when we setup the point, and just return the r
                value without any calculation whenever you want the distance from the origin. 
                This might be a requirement depending on how you are using it and one implementation
                may be better than the other, but from the user's perspective the same function is there
                there is self there is o distance. So, if I take a point and I ask for o distance I get the
                distance from the origin whether or not the point is represented using x y or r theta.
                Now, of course, using o distance is r theta is good for o distance not very good for
                translate. If I want to translate the point by delta x delta y, I have to convert the point
                back from r theta to x, y; using x equal to r cos theta and y equal to r sin theta then do x
                plus delta x, y to plus delta y and convert it back to r theta right. So, you pay a price in
                one function or the other; with the x y representation translate is better; with the r theta
                representation o distance is better. And this is a very typical case of the kind of
                compromise that you have to deal with and you have to decide which of these operations
                is slightly to be more common and more useful for you to implement directly.
                If you think translate happens more often it's probably better to use x and y; if you think
                origin from the distance is more important, so probably better to use r and theta. So,
                often there is no one good answer. It is not like saying that a heap implementation is
                always better than a sorted list implementation for a priority queue. There may be
                tradeoffs which depend on the type of use they are going to put a data structure to as to
                which internal implementation works worst best, but what you have to always keep in
                mind is that the implementation should not change the way the functions behave. To the
                external user, function must behave exactly the same way.
                <br><br>
                In this particular example just to illustrate what we have seen, again. We have changed
                the private implementation, namely we have moved from x, y to r theta, but the
                functionality of the public interface the functions o distance translate etcetera remain
                exactly the same.
                Now we have seen earlier that in python functions, we can provide default arguments
                which make sometimes the argument optional. So, for instance, if you want to say that if
                we do not specify the x and y coordinates over a point then by default the point will be
                created at the origin. Then we can use a equal to 0, and b equal to 0 as default arguments,
                so that if the user does not provide values for a and b, then x will be set to 0 and y will be
                set to 0. 
                For instance, if we want to point at a specific place 3 comma 4, we would invoke this
                function this class, we create an object by passing the argument 3 comma 4, but if we do
                not pass any argument like p 2 then we get a point at the origin.
                <br><br>
                The function init clearly looks like a special function because of these underscore
                underscore on either side which we normally do not see when we or normally do not
                thing of using to write a python function. As we said before python interprets init as a
                constructor, so when we call a object like p equal to 0.54, then this implicitly calls init
                and init is used to set up self dot x self dot y. The internal representation of the point is
                set up in the correct way by init. So, init is a special function. Now python has other
                special functions. 
                <br><br>
                For instance, one of the common things that we might want to do is to print out the value
                of an object, what does an object contain. And for this the most convenient way is to
                convert the object to a string. The function str normally converts an object to a string, but
                how do we describe how str should behave for an object, well there is special function
                that we can write called underscore underscore str. So, underscore underscore str is
                implicitly invoke when we write str of o. So, str of an object o is nothing but o dot
                underscore underscore str.
                And for instance, print - the function print implicitly takes any name you pass to print
                and converts it to a string represent, when I say print x and x is an integer implicitly str
                of x is what is displayed. So, str is invoked and str in turn internally invokes this special
                function underscore underscore str. Let us see how this would work for instance for our
                point thing. So, if we want to represent the points so internally we are self dot x and self
                dot y, we want to print this out in this form value x and the value y. 
                So, what we do? We set up str, so remember that self is always a parameter. So, what it
                does is, it first creates a string with the open bracket and the close bracket either end and
                a comma in the middle; and in between the open bracket and the comma it puts the string
                representation of self dot x and in between the comma and the close bracket it produces
                the string representation of self dot y. This creates a string from the value, it internally
                invokes str on the values themselves self dot x and self dot y and then constructs these
                extra things the open close bracket and the comma to make it look like a point as we
                would expect.
                <br><br>
                Another interesting function that python has as a special function is add. So, when we
                write plus the function add is invoked. In other words p 1 plus p 2, if these are two points
                would invoke p 1 underscore underscore add p 2. So, what we would expect that if I had
                p 1 and if I had p 2 then I would get something which gives me a point where I combine
                these two. 
                So, I get the x coordinate as x 1 p 1 plus p 2 and y coordinate p 1 plus p 2. It's up to us. I
                mean it does not mean it has to be this way, but if I say p 1 p 2 the function that is
                invoked is add. And it is up to us define what add means. Let us assume that we want to
                construct a new point whose x coordinate and y coordinate is the sum of the two points
                given to us. 
                <br><br>
                Here is way we would do it; we would create a new point whose x coordinate is self dot
                x plus p dot x. Now, notice that, self is the function associated with p 1 in this case, add;
                so self refers to p 1. When I say p 1 plus p 2 and the other argument p 2 is the point p.
                So, I can look at the values of p and say p dot x p dot y, I can look at my value and say
                self dot x self dot y, and now I can combine these by creating a new point self dot x plus
                p dot x and self dot x plus p dot y. 
                For instance, if we have two points at 1, 2 and 2, 5 then this will return a point at 3, 7 and
                I must store it in new point, so p 3 now becomes a new point whose x coordinate is 3 and
                y coordinate is 7.
                <br><br>
                In the same way, we could have a special way of defining multiplication, and in python
                the underscore underscore mult function is the one that is implicitly called by multiply.
                Similarly, we can define comparisons; we might say what is to be done when we
                compare whether p 1 is less than p 2, do we check both coordinates are less, we check
                the distance from the origin is less; we have complete freedom how to define this. 
                We just write p 1 less then p 2 for readability enough in our program, and internally it
                will call a function less than lt, similarly greater than will call the function gt, and there is
                something for less than equal to greater then equal to and so on. These are all very
                convenient functions that python allows us to call implicitly, and allows us to use
                conventional operators and conventional functions in our code. So, we do not really have
                to think of these objects in a different way when we are coding our programs. 
                There are several other such functions; it is impossible to list all of them and it is not
                useful to list all of them at this introductory stage when you are learning python, but you
                can always look up the python documentation, and see all the special functions that are
                defined for objects and classes.
                <br><br>
                
            </p>
        </div>
        <!--End of lecture 38-->

        <div id="lectrue39">
            <h2 id="userdefinedlists">7.3 &nbsp; User defined lists</h2>
            <p>
                Now that we have seen the basics about how to define classes and objects, let us define
                an interesting data structure.
                Suppose we want to implement our own version of the list, a list is basically a sequence
                of nodes and each node in the sequence stores a value and points to the next node. So, in
                order to go through the list we have to start at the beginning and walk following these
                pointers till we reach the last pointer which points to nothing. We have a list of the form
                v1, v2, v3, v4 in python notation. Then this is how we would imagine it is actually
                represented. There are 4 nodes. The list l itself which we have set up points to the first
                node in this list, v 1 points to v 2, v 2 points to v 3 and v 3 points to be v 4. The final
                node points to nothing and that indicates we have reached the end of the list.
                In this representation what would the empty list look like well it is natural to assume that
                the empty list will consist of a single node which has both the value and the next node
                pointers set to none, whereas for instance the singleton would be a single node in which
                we have the value v 1 and the next set to none. So, this is the convention that we shall
                follow for our representation of a list. So, notice that unless we have an empty list with a
                single node none, none no other node in a list can have value none, right. This is
                something that we will implicitly assume and use that checking for the value none will
                tell us it is an empty list and we will never find none in the middle of a list.
                We distinguish between a singleton and an empty list purely based on the value. Both of
                them consist of a single node. Now the reason that we have to do this is because actually
                python does not allow us to create an empty list if we say something like l is equal to
                none and we want this to denote the empty list the problem is that none does not have a
                type as far as python’s value system is concerned. So, once we have none, we cannot
                apply the object functions we are going to create for this list type. So, we need to create
                something which is empty of the correct type. So, we need to create at least 1 node and
                that is why we need to use this kind of representation in order to denote an empty list.
                <br><br>
                Here is the basic class that we are going to use, it is a class node. So, inside each node we
                have 2 attributes value and next as we said and remember that self is always used with
                every function to denote the object under consideration. We will use this default scheme
                that if we do not say anything we create an empty list. The init value, this should be init
                val. 
                The initial value is by default none unless I provide you an initial value in which case
                you create a list with that value and because of our assumption about empty list all we
                need to do to check whether a list is empty is to check whether the value at the initial
                node is none or not. We just take the list we are pointing to and look at the very first
                value which will be self dot value and ask whether it is none. If it is none, it is empty. If
                it is not none, it is not empty. 
                Here is a typical thing. We say l1 is equal to node; this creates an empty list because it is
                not provided any value. So, the default initial value is going to be none. If I say l2 is
                equal to node 5 this will create a node with the value 5. It will create the singleton list
                that we would normally write in python like this. If I ask whether l1 is empty, the answer
                will be true. If I ask whether l2 is empty, the answer will be false because self dot value
                is not none.
                <br><br>
                Now, once we have a list what we would like to do is manipulate it. The first thing that
                we might want to do is add a value at the end of the list. If the list is already empty, then
                we have a single node which has value none and we want to make it a singleton node, a
                singleton list with value v. So, we want to go from this to this, remember that in a
                singleton node we just have instead of none we have the value v over here so that is all
                we need to do. We need to just replace the none by v, if we are at the last element of the
                list and we know that we are at the last element of the list because the next value is none
                then what we need to do is create a new value.
                We walk to the end of the list and then we reach none. Now, we create a new element
                here with the value v and we make this element point to this, we create a new element
                with the node v and set the next field of the last node to point to the new node and if this
                is not the last value then well we can just recursively say to the rest of the list treat this
                as a new list starting at the next element, take the next element and recursively append v
                to that.
                <br><br>
                This gives us a very simple recursive definition of append. So, we take append and we
                want to append v to this list. If it is empty, then we just set the value to v. So, this just
                converts the single node with value none to the single node with value of v, otherwise if
                we are at the last node that is self dot next is none then we create a new node with the
                value v and we set our next pointer to point at the new node, remember when we create a
                new node the new node automatically is created by our init function with next none.
                We would now create a new node which looks like v and none and we will set our next
                pointer to point to it and the final thing is that if it is not none then we have something
                else after us. So, we go that next element self dot next and with respect to that next
                element we reapply the append function with the value v, this is the recursive call. 
                We have been abundantly careful in making sure that this is parsable. So, we have put
                this bracket saying that we take the object self dot next and apply append to that actually
                python will do this correctly. We need not actually put the bracket, we can just write self
                dot next dot append v and python will correctly bracket this as self dot next dot append.
                So, this dot is taken from the right.
                <br><br>
                Now, instead of recursively going to the end of the list we can also scan the end of the
                list till the end iteratively. We can write a loop which keeps traversing these pointers until
                we reach a node whose next is none. If the list is empty as before we replace the value
                none by v, otherwise we scan the list till we reach the last element and then once we
                reach the last element as in the earlier case we create a new node and make the last
                element point to it.
                This gives us an append which is iterative. So, we call it append i just to indicate that it is
                iterative. The first part is the same if the current list is empty then we just set the value to
                be v and we return, otherwise we now want to walk down the list. We set up a temporary
                pointer to point to the current node that we are at and so long as the next is none we keep
                shifting temp to the next value. So, we just write a loop which says while temp dot next
                is not none just keep going from temp to temp dot next.
                So, just keep shifting temp. Finally when we come out of this loop at this point we know
                that temp dot next is none. This is the condition under which we exit the loop. We have
                reached, the node temp is now pointing to the last node in the current list. At this point
                we do exactly what we did in the recursive case we create a new node with a value v and
                we make this last node point to this new node. So, we reset next of temp from none to the
                new node.
                <br><br>
                What if we do not want to append, but we want to insert. Now it looks normally that
                insert should be easier that append, but actually insert is a bit tricky. So, by insert we
                mean that we want to put a value at the beginning. We want to put a node here which has
                v and make this pointer. 
                This is what we want to do now. The problem with this really is that after we create a
                new node we cannot make this point here and this point here there is no problem in
                making the new node point to v 1, but if we reassign the value of l or inside a object if
                we reassign the value of self then this creates a completely different object. We saw this
                when we were looking at how parameters are passed and immutable value are passed. 
                We said that if we pass a mutable value to a function so long as we do not reassign that
                thing any mutation inside the function will be reflected outside the function, but if we
                reassign to the list or dictionary inside the function we get a new copy and then after that
                any change we make is off. So same way if we reassign l or self to point to a new node
                then we will lose the connection between the parameter we passed to the function and the
                parameter we get back. So, we must be careful not to make l point to this thing. We
                cannot change where l points to. So, how do we get around this problem? We have
                created a new node, we want to make l point to it, but we are not allowed to do so,
                because if we do so, then python will disconnect the new l from the old l. So, there is a
                very simple trick. What we do is we do not change the identity of the node, we change
                what it contains. So, we know now that v 1 is the old first node and v is a new first node,
                but we cannot make l point to the new first node, so we exchange the values. So, what
                we do is we replace v 1 by v and v by v 1. 
                Now, the values are swapped and we also have to do a similar thing for what is pointing
                where. So, l is now pointing to v as the first node, but now we have bypassed v 1 which
                is a mistake. We must now make the first node point to the new node and the new node
                point to the old second node. So, by doing this kind of plumbing what we have ensured is
                that the new list looks like we have inserted v before the v 1, but actually we have
                inserted a new node in between v and v 2 and we have just changed the links to make it
                appear as though the new node is second and not first.
                <br><br>
                Here is the code for insert. As usual, if you have an empty list insert is easy. We just have
                to change none to v. So, insert and append both behave the same way with an empty list.
                We go from the empty list to the list v. It does not matter whether you are inserting or
                appending. Otherwise, we create this new node and then we do this swapping of values
                between the current node that self is pointing to, that is the head of the list and the new
                node.
                We exchange the values; we set self dot value to new node dot value and simultaneously
                new node dot value to self dot value using this python simultaneous assignment. And
                similarly we take self dot next which was pointing to the next node and make it point to
                the new node and the new node instead should point to what we were pointing to earlier.
                So, new node dot next is self dot next. This is how we insert and insert as we saw is a
                little bit more complicated than append because of having to handle the initial way in
                which l points to the list or self points to the list.
                What if we want to delete a node? How do we specify to delete a node? Well we specify
                it by a value, but let us just suppose you want to delete say the second node in this list.
                Now, how would we delete it? Well again just as we did insert we would do some re
                plumbing or re connection. So, we take the node that we want to delete and we just make
                the link that points to v 2 bypass it. So, we take the link from v 1 and make it directly
                point to v 3. So, in essense, all that delete requires us to do is to reassign the pointer from
                before the deleted node with the pointer after the deleted node. It actually does not
                physically remove that object from memory, but it just makes it inaccessible from the
                link end.
                <br><br>
                We provide a value v and we want to remove the first occurrence of v. We scan the list
                for the first v. Now notice that in this plumbing procedure we need to be at v 1 in order to
                make it point to v3. If we wanted to delete the next node then we are in good shape
                because we can take the next dot next and assign it to the current next. So, we should
                look 1 step ahead. If you are already at v 2 then we have gone past v 1 and we cannot go
                back to v 1, easily the way we have set up our list because it only goes forward; we
                cannot go back to v 1 and change it.
                What we will actually do is we will scan by looking at the next value. If the self dot next
                dot value is v that is if the next node is to be deleted then we bypass it by saying the
                current node’s next is not the next node that we had, but the next node’s next. So, self dot
                next is reassigned to self dot next dot next - bypass the next node. As before like with
                insert the only thing we have to be careful about is if we have to delete actually the first
                value in the list.
                If you want to delete the first value in the list exactly like we had with insert the natural
                thing would be to, now say that l should point to the second value in the list, but we
                cannot point l there because if we reassign the node that l points to then it will create a
                new object and it will break the connection between the parameter we passed and the
                thing we get back. We use the same trick. What we do is we copy the value v 2 from the
                next node and then... So we just copy this value from here to here and then we delete v 2.
                So, we wanted to delete the first node, we are not allowed to delete the first node because
                we cannot change what l points to. So, instead we take the value in the second node
                which was v 2, copy it here and then pretend we deleted v 2 by making the first node
                point to the third.
                <br><br>
                Here is a part of the delete function. First of all, if we were looking for v and then we do
                not find it. So, sorry in this code, it is called x. So, this is deleting value x if you want. If
                we say that the list is empty, then obviously, we cannot delete it because delete says if
                there is a value of this... node with value x then delete it. If it is empty we do nothing;
                otherwise if this self dot value is x the first node is to be deleted. Then if there is only 1
                node, then we are going from x to empty, this is easy. If there is no next node right, if we
                have only a singleton then we just set the value to be none and we are done.
                This is the easy case, but if it is not the first node, I mean, it is the first node and this is
                not also the only node in the list then what we do is we do what we said before. We copy
                the next value. We pretend that we are deleting the second node. So, we copy the second
                value into the first value and we delete the next node by bypassing. This is that bypass.
                This is part of the function; this is the tricky part which is how do you delete the first
                value. If it is only 1 value, make it none; if not, bypass the second node by copying the
                second node to the first node.
                And if this is not the case then we just walk down and find the first x to delete. We start
                as… this is like our iterative append. We start pointing to self and so long as we have not
                reached the end of the list if we find the next value is x and then we bypass it and if you
                reach the end of the list, we have not found it, we do nothing, we just have to return. In
                this case it is not like append where when we reached the end of the list we have to
                append here, if we do not find a next by the time we reach the end of the list, then there’s
                nothing to be done.
                So, just for completeness, here is the full function, this was the first slide we saw which
                is the case when the value to be deleted is in the first node and this is the second case
                when we walk down the list looking for the first x to delete.
                Just like append can be done both iteratively and recursively, we can also delete
                recursively which is if it is the first node we handle it in a special way by moving the
                second value to the first and bypassing it as we did before. Otherwise we just point to the
                next node and ask the next node, the list starting at the next node, what is normally called
                the tail of the list, to delete v from itself. The only thing that we have to remember in this
                is that if we reach the end of the list and we delete the last node. Supposing it turns out,
                the value v to be deleted is here. So, we come here and then we delete it. What we will
                end up with is finding a value none, because when we delete it from here, it is as though
                we take a singleton element v and delete v from a singleton and will create none none.
                So, this is the base case, if we are recursively deleting as we go whenever we delete from
                the last node, it is as though we are deleting from a singleton list with value v and we are
                not allowed to create a value none at the end.
                <br><br>
                We have to just check when we create the next thing if we delete the next value and it is
                value becomes none then we should remove that item from the list. So, this is the only
                tricky thing that when we do a recursive delete you have to be careful after we delete you
                have to check what is happening.
                This part is the earlier part and now this is recursive part. So, recursive part is fairly
                straight forward. So the first part is when we delete the first element from a list, but the
                recursive part we check if self dot next is equal to none then we delete recursively that is
                fine. So, this is the delete call.
                Now, after the delete is completed we check whether the next value has actually become
                none. Have we actually ended up at the last node and deleted the last node? If so, then
                we remove it, this we can either write self dot next is equal to self dot next dot next or we
                could even just write self dot next is equal to none which is probably a cleaner way of
                saying it because it can only happen at the last node. So, you make this node the last
                node. Remember if the next node is none, it’s next must also be none. 
                This has the same effect: self dot next dot next must be none. So, we can also directly
                assign self dot next is equal none and it would basically make this node the last node.
                The only thing to remember about recursive delete is when we reach the end of the list
                and we have deleted this list this becomes none then we should terminate the list here
                and remove this node.
                Finally let us write a function to print out a list. So, that we can keep track of what is
                going on. We will print out a list by just constructing a python list out of it and then using
                str on the python list. So, we want to create a python list from the values in our list. So,
                we first initialize our list that we are going to produce for the empty list.
                If our list, the node itself has nothing then we return the string value of the empty list,
                otherwise we walk down the list and we keep adding each value using the append
                function. So, we keep appending each value that we have stored in each node building up
                a python list in this process and finally, we return whatever is the string value of that list.
                Let us look at some python code and see how this actually works.
                <br><br>
                Here we have code which exactly reflects what we did in the slides. We have chosen to
                use the recursive versions for both append and delete. So, we start with this initial
                initialization which sets the initial value to be none by default or otherwise v as an
                argument provided.
                Then isempty just checks whether self dot value is none, we had written a more compact
                form in the slide by saying just return self dot value equal to equal to none, but we have
                expanded it out as an if statement here.
                Now, this is the append function. So, append just checks if the current node is empty then
                it puts it here otherwise it creates a new node... if we have reached the last node it creates
                a new node and makes the last node point to the new node, otherwise it recursively
                appends. Then we have this insert function here.
                This insert function: again if it is empty then it just creates a singleton list otherwise it
                creates a new node and exchanges the first node and the new node. So, this particular
                thing here is the place where we create this, swap the pointers so that what self points to
                does not change, but rather we create a reordering of the new node and the first node. So,
                the new node becomes the second node and the first node now has the value that we just
                added.
                <br><br>
                Finally, we can come down to the recursive delete. So, the recursive delete again says
                that if the list is empty then we do nothing, otherwise if the first value is to be deleted
                then we have to be careful and we have to make sure we delete the second value by
                actually copying the second node into the first and finally, if that is not the case then we
                just recursively delete, but then when we finish the delete, we have to delete the spurious
                empty node at the end of the list in case we have accidentally created it. 
                So, these 2 lines here just make sure that we do not leave a spurious empty node at the
                end of the list. And finally, we have this str function which creates a python list from our
                values and eventually returns a string representation of that list.
                If we now run this by importing, then we could say, for instance, that l is a list with value
                0 and if we say print l then we will get this representation 0, we could for instance put
                this in a loop and say for i in range 1 say 11, l dot append i.
                And then if we at this point print l then we get 0 to 10 as before.
                Now we say l dot delete 4 for instance and we print l then 4 is formed and so on. If we
                say l dot insert 12 and print l, then 12 will begin. So, you can check that this works.
                Notice that we are getting these empty brackets, this is the returned value. So, when we
                wrote this return, we wrote with the empty argument. And then we get this empty tuple,
                we can just write a return with nothing and then it would not display this funnier return
                value, but what is actually important is that the internal representation of our list is
                correctly changing with the functions that we have written.
                <br><br>
                
            </p>
        </div>
        <!--End of lecture 39-->

        <div id="lectrue40">
            <h2 id="Searchtrees">7.4 &nbsp;  Search trees</h2>
            <p>
                As a final example of a user defined data structure we will look at binary search keys.
                We are looking at a situation where we need to maintain dynamic data in a sorted
                manner, remember that one of the byproducts of sorting is that we can use binary search
                to efficiently search for a value, but binary search can be used if we can sort data once
                and for all and keep it in sorted order if the data is changing dynamically then in order to
                exploit binary search will have to keep resorting the data which is not efficient. 
                Supposing, we have a sequence of items and items are periodically being inserted and
                deleted now as we saw with heaps, for instance, if we try to maintain a sorted list and
                then keep track of inserts then each insert or delete, in this case would take order and
                time and that would also be expensive. However, it turns out that we can move to a tree
                like structure or a tree structure like in a priority queue it move to a heap and then do
                insert and delete also efficiently alongside searching. 
                <br><br>
                The data structure we have in mind is called a binary search tree. So, in a binary search
                tree we keep exactly one copy of every value. It is like a set we do not keep duplicates
                and the values are organized as follows for every node all values which are smaller than
                the current nodes value are to the left and all values that are bigger than the current node
                value are to the right. 
                Here is an example of a binary search tree, you can check for instance that to the left of
                the root 5, we have all values 1, 2 and 4 which are smaller than 5 and to the right of 5 we
                have the values 8 and 9 which are bigger, now this is a recursive property. If you go
                down, for instance, if you look at the node label two then below it has values 1 and 4
                since 1 is smaller than 2, 1 is to the left of 2 and since 4 is bigger than 2, 4 is to the right
                of 2.
                Similarly, if we look at the node 8, it has only one value below it namely 9 and therefore,
                it has no left child, but 9 is in the right subtree of 8.
                We can maintain a binary search tree using nodes exactly like we did for a user defined
                lists except in a list we had a value and a next pointer in a binary search tree we have two
                values below each node potentially a left child and a right child. So, each node now
                consist of three items the value being stored the left child and the right child. 
                If we look at the same example that we had 4 on the right then the root node 5 will have
                a pointer to the nodes with 2 and 8, the node 2 will have a pointer to the nodes 1 and 4,
                these are now what are called leaf nodes. So, they have no children. Their left and right
                pointers will be None indicating there is nothing in that direction. Similarly, 8 has got
                None as his left pointer because it has no left child and the right pointer points to 9 and
                the node with nine again has two None pointers because it is a leaf node.
                <br><br>
                Now, it will turn out that we will want to expand this representation in order to exploit it
                better for recursive presentations. So, what we will do is that we will not just terminate
                the tree with the value and the two pointers none you will actually add a layer of empty
                nodes with all fields None with this the empty tree will be a single empty node and a leaf
                node that is not none will have a value and both it is children will be empty nodes. 
                It would not directly have None as it is left and right pointers it will actually help
                children which are empty. So, this makes it easier to write recursive functions and if we
                do not do this then it is a bit harder to directly implement recursive functions.
                Just to understand how our tree structure changes this is the structure that we had before
                the same example. Here, notice that in the leaf nodes the leaf nodes have a value and
                both the child pointers left and right are directly none. So, we want to change this, what
                we want to do is to we want to insert below this an empty node at everywhere, where we
                see None, we want to insert and extract the node. 
                This of course, grows up the tree a little bit, but then this cost is not that much as we will
                as you can calculate. So, if we do this then we get a new tree which looks like this right
                Below every leaf node wherever we normally had a None pointer indicating that the path
                has ended we will explicitly add one extra node which has all three fields none and it will
                turn out that this is very useful to clean up our programming later on. So, this is a
                representation that we will use for a binary search tree each node has three pointers and
                at the leaf’s we have an extra layer of empty nodes with all three values none, none,
                none.
                <br><br>
                Here is the basic class tree. So, as before we have an init function which takes an initial
                values which is by default none. The init function works as follows right, we first setup
                the value to be initval which could be none if there is a value, then we create an tree with
                one node in which case we have to create these empty nodes. Now, notice that if we go
                back and we go do not give a values. So, maybe it is better to look at this case right if we
                do not give a value then we end up with a tree we just says none, none, none. So, this is
                our empty.
                The initial value is none we get this tree if the init value is not none then we get a tree in
                which we put the value v and then we make the left in the right pointers both point to this
                none, none. So, this is a tree that will contain exactly one value. So, depending on that
                the init values none or not none we end up either a tree with three nodes with two
                dummy nodes below or a single empty node denoting the empty tree. So, given this as
                before we have the function isempty which basically checks if the value is none, if I start
                looking at a tree and the very first node says none then that tree is empty otherwise it is
                not empty.
                <br><br>
                Let us first look at a way to systematically explore the values in a tree. These are called
                traversals and one traversal which is very useful for a binary search tree is an inorder
                traversal. So, what an inorder traversal does is that it first explores the left side. So, it
                will first explore this recursively again using an inorder traversal then it will display this
                and then it will explore the right. 
                If you see the code you can see that if the tree is not empty you first do an inorder
                traversal of the left self tree then you pick up the value at the current node and then you
                do an inorder traversal of the right self tree and this produces the list of values. So, if we
                execute this step by step, 5 if we reach it says first do an inorder traversal of the left.
                We come down to two this is again not at a trivial tree. So, again we have to do a inorder
                traversal. So, we go it is left and now when we have one and inorder traversal of one
                consists of it is left child which is empty one and then it is right child is empty. So, this
                produces one now I come back and I list out the node two and now I do an inorder
                traversal of it is right. So, I have got 1, 2, 4. So, this completes inorder traversal of the
                left subtree of 5. Now, I list out 5 itself and then I do an inorder traversal of 8 and 9 since
                8 has no left child the next values are comes out as a 8 itself and then 9. 
                So, what you can see is that since we print out the values on the left child before the
                current value when the value is the right child after the current value with respect to the
                current value all these values are sorted because that is how the search key is organized
                and since is recursively done at every level down the final output of a inorder traversal of
                a search tree is always a sorted list. This is one way to ensure that the tree that you have
                constructed is sorted you do an inorder sub traversal that the key of constructed is a
                search tree you do an inorder traversal and ensure that the output that you get from this
                traversal is a sorted list.
                <br><br>
                As we mentioned that the beginning of this lecture, one of the main reasons to construct
                a search tree is to be able to do something like binary search and this is with dynamic
                data. So, we will also have insert and delete as operations, but the main fundamental
                operation is find. 
                Like in binary search we start at the root. So, you imagine that this is the middle of an list
                of an array, for example, we look at this element if we have found it it is fine if we have
                not found it then we need to look in the appropriate sub tree since the search tree is
                organized with the left values smaller in the right value is bigger we go left if the value
                we were searching for is smaller than the current node and we go right if it is larger than
                the current node. So, this is very much a generalization of binary search in the tree.
                Here is the code, it is very straight forward we want to find value of v remember, this is
                this python syntax. We always have the self as the first parameter to our function. So, if
                the current node is empty we cannot find it. 
                So, it is v return false if we do find v then we return true and if we do not find v then if it
                is. This is not, it should be self if it is smaller than this current value then we go left and
                search for it otherwise we go right and search for it. So, this is exactly a binary search
                and it is a very simple recursive thing which exactly follows a structure of a search tree.
                <br><br>
                It will be useful later on to be able to find the smallest and largest values in a search tree.
                So, notice that as we keep going left we go smaller and smaller. So, where is the
                minimum value in a tree it is along the smaller left most path. So, if I have to go from the
                left most path and if I cannot go any further then I find it. So, we will always apply this
                function only when tree is non empty. Let us assume that we are looking for the
                minimum value in a non empty tree. Well, we find the left most path.
                If I cannot go further left then I found it. In this case, if I reach one since I cannot go
                further one is the minimum value otherwise if I can go left then I will go one more step.
                So, if we start this, for instance, say 5 it will say that 5 have left a subtree. So, the
                minimum value below 5 is the minimum value below it is left child. So, you go to three
                now we say that the minimum value below three is the minimum value below it is left
                child. So, you go to one then we say that the minimum value is the minimum value at 1
                because there is no left child and therefore, we get the answer 1 and it is indeed 2 that
                anything below that is only on the right that is 2.
                Dually, one can find the maximum value by following the right most path right, if the
                right is none then we return the current value otherwise we recursively look for the
                maximum value to our right. 
                In this case we start at 5, we go down to 7, then we go down to 9 and since there is no
                further right path from 9, 9 must be the maximum value in this tree. We will come back
                later on and see why we need this minimum and maximum value, but any way it is
                useful thing to be able to find and it is very easy to do, again using the structure of the
                binary search.
                <br><br>
                So, one of the things we said is that we need to be able to dynamically add and remove
                elements from the tree. The first function that we look for is insert, how do we insert an
                element in the tree well it is quite easy we look for it if we do not find it then the place
                where are search concludes is exactly where it should have been. So, we insert it at that
                point right. 
                For example, supposing we try to insert 21 in this tree, when we look at 52 and when go
                left when we go left then we come to 16 again and we go right then we come to 21, 28
                and we find that we have exhausted this path and there is no possible 21 in this tree, but
                had we found 21 it should be to the left of 28. So, we insert it there. So, we look for
                where it should find it and if we do not find it we insert it with the appropriate place.
                Similarly, you can start and look for 65. So, 65 is bigger than 52. So, we go over right
                then it is smaller than 74. So, we go left, but there is nothing to the left 74. So, we out it
                to the left of 74.
                Now, insert will not put in a value that is already there because we have no duplicates.
                So, if now we try to for instance insert ninety one then we go right from 52 we go right
                from 74 and now we find that 91 is already present in the tree. So, insert ninety one has
                no effect on this tree.
                This is a very simple modification of the find algorithm. So, we keep searching and if we
                reach the leaf node then we come to an empty node right. If you find that we have
                reached an empty node then we do the equivalent of creating a new node here we set this
                value to be v and we create a new frontier below by adding two empty nodes in the left
                and right rather than just having none. 
                On the other hand, if we find the value in the tree we do nothing and if we do not find the
                value then we just use the search tree property and try to insert either on the left or on the
                right as appropriate.
                <br><br>
                How about delete. So, delete is a little bit more complicated than insert. So, basically
                whenever we find v in the tree and that can only be one v remember this is not like
                deleting from the list that we had before where we were removing the first copy of v in a
                search tree we have only one copy of every value if at all. If we find v we must delete it. 
                So, we search for v as usual now if the node that we are searching for is a leaf then we
                are done we just delete it and nothing happens, if it has only one child then we can
                promote child. If it has two children we have a hole we have a leaf we have a node which
                we have to remove value, but we have values on both sides below it and now we will use
                this maximum function maxval or minval in order to do the work. Let us just see how
                this works through some examples right. So, supposing we first delete 65 then we first
                search for 65, we find it since it is a leaf then we are in this case the first case we just I
                have to remove this leaf and we are done.
                Now, we try to delete 74. So, we find 74 and we find that it has only one child. So, if it
                has only one child then we move this out then we can just effectively short circuit this
                link and move this whole thing up and make 52 point to 91 directly. So, we are in this
                second case this is what it means to promote the child. So, the deleted node has only one
                child we can bypass the child and directly connect the parent of the deleted node to the
                one child of the deleted node. So, this will result in 91 moving up there.
                <br><br>
                Now, finally, we have the difficult case which is you want to delete a node which is in
                the middle of the tree, in case this case 37. So, we come to 37 and we want to remove
                this. Now, if we remove this there will be a vacancy now, what do we fill the vacancy
                again and how do we adjust the shape of the tree. So, we look to the left and find the
                maximum value remember that everything to the left is smaller than 37 and everything to
                the right is bigger than 37.
                So, among the left nodes we take the biggest one and we move it there then everything to
                the left will remain smaller than that node you could also do it the other way and take the
                smallest values from the right, but you would not do that you will stick to taking the
                maximum value from the left. We go to the left and find the maximum value is 28. So,
                basically we have taken this 28 and moving it up there
                Now, we should not have two copies of 28. So, we need to remove this 28. So, how do
                we do that well within this subtree, we delete 28 now this looks like a problem because
                in order to delete a node we are again deleting a node, remember that the way that the
                maximum value was defined it is along with the right most path. So, the right most path
                will either end in leaf or it will end in the node like this which has only one child and we
                know that when we have a leaf or only one child we are in the first two cases which we
                can handle without doing this maximum value that. So, we can just walked out remove
                the 28 and promote the 21. So, this is exactly how delete works.
                We can now look at the function. If there is no value v then we just return the easy cases
                are when we do not find we are the current thing. So, if it is less than the current value
                then we go to the left and delete if it is bigger than the current value we go to the right
                and delete. So, the hard work comes then we actually find v at the current value. If this is
                a leaf now we have not shown, how write this function if this is a leaf this means that it
                has left and right child both as empty nodes if this is a leaf then we will make it empty
                we will see how we do this in a minute I will just show you the code for this. 
                <br><br>
                So, if this is a leaf we delete it right this is the first case is simple case this is the leaf we
                just delete it and we make this node empty if on the other hand it has only one child, if.
                So, actually in this case if the left is empty then we just promote the right and if it is left
                is not empty then we will copy the maximum value from the left and delete the
                maximum value on the left.
                We need to just see these two functions here make empty and copy right. So, make
                empty just says convert this into an empty node an empty node is one which all three
                fields are none. So, we will just say self dot value is none self dot left is none self dot
                right is none. If it had an empty node hanging of it those empty nodes are now
                disconnected from return. 
                This is this make empty function and now the copy right function just takes everything
                from the right and moves it up. It takes the right value and makes it the current value the
                left value right dot left and makes with the left. So, we just take basically this node and
                copy these values one by one here. So, we copy right dot value to the current value right
                dot left to the current left right dot right to the current right.
                So, how much time do all these take well if you examined the thing carefully you would
                realize that in every case we are just walking down one path searching for the value and
                along that path either we find it or we go down to the end and then we stop. So, the
                complexity of every operation is actually written by the height of the tree if we have a
                balanced tree a balanced tree is one where you can define that each time we come to a
                node the left in the right chair roughly have the same size.
                <br><br>
                If we have a balanced tree then it is not difficult to see then we have height logarithmic
                in an this is like a heap a heap is an example of a balanced tree now search tree will not
                be has nicely subset of heap because we will have some holes, but we will have a
                logarithmic height in general we will not explain how to balance a tree in this particular
                course we can look it up you can look for topic called AVL trees which is one variety of
                balanced trees which are balanced by rotating sub trees. So, it is possible while doing
                insert and delete to maintain balance at every node and ensure that all these operations
                are logarithmic.
                Let us just look at the code directly and execute it and convenience ourselves that all the
                things that we wrote here actually work as intended.
                Here we have a python code for the class tree that we showed in the lectures. So, we are
                just added a comment about how the empty node is organized and the leaves are
                organized. So, there is the constructor which sets up either an empty node or a leaf node
                with two empty children then we have isempty and iseleaf we check whether the current
                value is none or both the left and right children are empty, respectively.
                Then we have this function makeempty which converts the leaf to an empty node
                copyright, copies a right child values to the current node and then we have the basic
                recursive functions.
                So, we start with find. So, find is the one which is equivalent to binary search then insert
                is like find and there it where it does not find it tries to insert.
                <br><br>
                And finally, we have maxval which we made for delete and delete now when we reach
                the situation where we are found a value to that needs to be deleted if it is a leaf then we
                remove the leaf and make it empty if it is the left child is empty then we copy the right
                child up otherwise we delete the maximum from the left and promote that maximum
                value to a current.
                (Refer Slide Time: 21:12)
                Finally, we have this inorder traversal which generates a sorted list from the tree values
                and the str function just displays the inorder traversal.
                (Refer Slide Time: 21:22)
                Now if we go to this then we can for instance import this package set up an empty tree
                and then put in some random values it is important not put in sorted order, otherwise a
                sorted tree if you just insert one at a time it will just generate one long path. So, I am just
                trying to put it in some random order. We insert into the tree all these values and now we
                are print t give me a sorted version of this. So, 1, 2, 3, 4, I can now insert more values.
                So, I can for random insert 17 and verify that now 17 is there before 14 and 18 and I can
                keep doing this, I can insert I can even insert values in between like 4.5 because I have
                not in specified the integers right. So, it puts a between 4 and 5 and so on and now I can
                delete, for example if I delete 3 then I find that I have 1, 2, 4. If I delete, for example, 14
                then I have no longer 14 between 7 and 17 and so on.
                This incrementation definitely works, although we have a balanced it. If we do not
                balance it then the danger is that if we keep inserting and sorted sequence then we keep
                inserting larger values it keeps adding on the right child. So, the tree actually looks like a
                long path right. Then it becomes like a sorted list and every insert will take order n time,
                but if we do have rotations built in as we do, we could be using an AVL tree then we can
                ensure that the tree never grows to height more than log n. 
                So, all the operations insert, find and delete they always be logarithmic respect to the
                number of values currently being maintained.
                <br><br>
                
            </p>
        </div>
        <!--End of lecture 40-->                     
    </div>
    <!--End of week 7-->

</div>  
</body>
</html>
